{"./":{"url":"./","title":"目录","keywords":"","body":"目录 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-20 23:58:54 "},"view/":{"url":"view/","title":"面试点","keywords":"","body":"面试点 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-20 23:58:57 "},"view/juc/":{"url":"view/juc/","title":"JUC","keywords":"","body":"JUC Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-20 00:03:46 "},"view/juc/volatie.html":{"url":"view/juc/volatie.html","title":"volatie","keywords":"","body":"volatile 概念 volatile是java虚拟机提供的轻量级的同步机制 保证可见性 （多线程中，某个线程修改了工作内存中变量值，并同步到主内存中的变量值，该变量值的变化，对其它线程是可见的。其它线程使用该值时，会去主内存中重新获取值） 不保证原子性 （不可分割，完整性。要么全部执行，要么全部不执行） 禁止指令重排 保证可见性 多线程中，主内存中变量值的变化，会通知其它线程。其它线程调用时，会重新去主内存中进行拷贝。 class myData { volatile int number = 0; public void addTo60() { this.number = 60; } } public void showVolatile() { myData myData = new myData(); new Thread(()->{ System.out.println(Thread.currentThread().getName() + \" come in\"); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } myData.addTo60(); System.out.println(Thread.currentThread().getName() + \" update value :\" + myData.number); }, \"AAA\").start(); while (myData.number == 0) { //AAA线程修改number后，会刷新到主内存中，并通知main线程。跳出while循环 } System.out.println(Thread.currentThread().getName() + \" value:\" + myData.number); } 不保证原子性 某个线程对工作空间的值修改，刷新到主内存中的同时。其它线程被挂起。当其它线程唤醒时，由于CPU执行快，变量值的变化还没来得及通知，其它线程就把各自工作空间中的值刷新回主内存。导致主内存值覆盖丢失 class myData { volatile int number = 0; public void addPlusPlus() { number++; } } public static void main(String[] args) { myData myData = new myData(); for(int i = 1; i { for (int j = 0; j 2) { //2代表，后台有一个 main线程和GC线程。大于2，代表上述线程还没有执行完成。 Thread.yield(); } System.out.println(Thread.currentThread().getName() + \" Int value:\" + myData.number); //值不一定为20000，多线程覆盖丢失，不保证原子性 System.out.println(Thread.currentThread().getName() + \" AtomicInteger value:\" + myData.atomicInteger); //CAS原子操作，保证原子性 } 如何解决原子性 加sync （如synchronized） 使用JUC下的atomicInteger （参见不保证原子性示例） class myData { volatile int number = 0; AtomicInteger atomicInteger = new AtomicInteger(); public void addMyAtomic() { atomicInteger.getAndIncrement(); } } 禁止指令重排 volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。 计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下3种： 单线程环境确保程序最终执行结果和代码顺序执行的结果一致。处理器进行重排序时，须考虑指令间的数据依赖性多线程环境中线程交替执行，由于编译器优化重排存在，两个线程中使用的变量能否一致是无法确定的，结果无法预测。 内存屏障（Memory Barrier），又称内存栅栏，是一个CPU指令。通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。另一个作用：强制刷出各种CPU的缓存数据，因些任何CPU上的线程都能读取到这些数据的最新版本。 对volatile变量进行写操作，加入一条store屏障指令，将工作内存中的共享变量值刷新回到主内存； 对volatile变量进行读操作，加入一条load屏障指令，从主内存中读取共享变量 jvm java虚拟机 JMM(java Memory Model) java内存模型 JMM本身是一种抽象的概念，并不真实存在。它描述的是一级规则或规范。通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式 JMM关于同步的规定 线程解锁前，必须把共享变量的值刷新回主内存 线程加锁前，必须读取主内存的最新值到自已的工作内存 加锁解锁是同一把锁 特点 可见性 原小性 有序性 DCL(双端检锁机制) 单例模式下的 volatile分析 DCL(双端检锁)机制不一定线程安全，原因是有指令重排序的存在，加入volatile可以禁上指令重排 public class SingletonDemo { private static SingletonDemo instance = null; private SingletonDemo() { System.out.println(Thread.currentThread().getName() + \"\\t 我是构造方法，我怕谁\"); } //DCL(Double check Lock) 双端检锁机制 public static SingletonDemo getInstance() { if (instance == null) { synchronized (SingletonDemo.class) { if (instance == null) { instance = new SingletonDemo(); } } } return instance; } //单线程下的单例模式 public static SingletonDemo getInstance() { if (instance == null) { instance = new SingletonDemo(); } return instance; } public static void main(String[] args) { for(int i = 1; i { SingletonDemo.getInstance(); }, String.valueOf(i)).start(); } } } 原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化instance = new SingletonDemo();可以分为以下3步完成（伪代码） memory = allocate(); //1、分配对象内存空间 instance(memory); //2、初始化对象 instance = memory; //3、设置instance指向刚分配的内存地址，此时instance!=null 其中2和3不存在数据依赖关系，无论重排前还是重排后程序执行结果在单线程中并没有改变。因此这种重排优化是允许的。 memory = allocate(); //1、分配对象内存空间 instance = memory; //3、设置instance指向刚分配的内存地址，此时instance!=null。但是对象还没有初始化完成 instance(memory); //2、初始化对象 **所有当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。** 解决方案 在instance定义处，加上volatile关键字，禁止指令重排。 private static volatile SingletonDemo instance = null; Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-20 21:48:28 "},"view/juc/cas.html":{"url":"view/juc/cas.html","title":"CAS","keywords":"","body":"CAS 不加锁，保证一致性。但是自旋锁需多次比较，CPU开销大。 synchronized 一致性保证，并发性下降。 CAS ---> UnSafe ---> CAS底层原理 ---> ABA ---> 原子引用更新 ---> 如何规避ABA问题 CAS(compare and swap) 在计算机科学中，比较和交换（Conmpare And Swap）是用于实现多线程同步的原子指令。它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。 CAS并发原语体现在sum.mics.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。是依赖硬件的功能，实现原子操作。 CAS是系统原语，由若干条指令组成，原语的执行必须是连续的，不允许被中断。不会造成数据不一致的问题。 底层原理 AtomicInteger atomicInteger = new AtomicInteger(); public void addMyAtomic() { atomicInteger.getAndIncrement(); } Unsafe类 (jdk中sun.misc) public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; unsafe.getAndAddInt public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } 底层汇编 自旋锁 getAndAddInt中的do while循环，线程循环检测工作内存中的值与主内存中的值是否相等，不等的话，则失败，则继续循环检测。相等，则更新主内存中的值。 CAS缺点 循环时间长开销很大。（由于do while检测，如果值一直改变，则会一直循环尝试，CPU开销增大） 只能保证一个共享变量的原子操作 引出来ABA问题？？？ ABA问题 多线程中，one、two线程各自从主内存取出变量A，two线程由于执行快，先将主内存中的值刷新为B，又刷新为A。当one线程CAS检测时，发现主内存中的值为A，与自已工作空间中的值相等，就将自身的值刷新回主内存。 one线程刷新值成功，不代表中间过程就没有问题。 解决手段 （原子引用） class User { String userName; int age; User(String userName, int age) { this.userName = userName; this.age = age; } public void setUserName(String userName) { this.userName = userName; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"userName='\" + userName + '\\'' + \", age=\" + age + '}'; } } public class AtomicReferenceDemo { public static void main(String[] args) { User z3 = new User(\"z3\", 22); User li4 = new User(\"li4\", 25); AtomicReference atomicReference = new AtomicReference<>(); atomicReference.set(z3); System.out.println(atomicReference.compareAndSet(z3, li4) + \" value: \" + atomicReference.get().toString()); System.out.println(atomicReference.compareAndSet(z3, li4) + \" value: \" + atomicReference.get().toString()); } } 时间戳原子引用（新增一种机制，就是类似修改版本号） T1 100 1 100 1 T2 100 1 101 2 100 3 public class ABADemo { static AtomicReference atomicReference = new AtomicReference<>(100); //原子引用 static AtomicStampedReference atomicStampedReference = new AtomicStampedReference<>(100, 1); //时间戳原子引用 public static void main(String[] args) { System.out.println(\"===============ABA生成=====================\"); new Thread(() -> { atomicReference.compareAndSet(100, 101); atomicReference.compareAndSet(101, 100); }, \"t1\").start(); new Thread(() -> { try { TimeUnit.SECONDS.sleep(1); //让t1线程生成一次ABA操作 } catch (InterruptedException e) { e.printStackTrace(); } atomicReference.compareAndSet(100, 2019); System.out.println(Thread.currentThread().getName() + \"\\t value: \" + atomicReference.get().toString()); }, \"t2\").start(); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"===============ABA解决=====================\"); new Thread(() -> { int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName() + \"\\t 第1次版本号： \" + stamp); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName() + \"\\t 第2次版本号： \" + atomicStampedReference.getStamp()); atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName() + \"\\t 第3次版本号： \" + atomicStampedReference.getStamp()); }, \"t3\").start(); new Thread(() -> { int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName() + \"\\t 第1次版本号： \" + stamp); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } boolean result = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1); System.out.println(Thread.currentThread().getName() + \"\\t 刷新成功否： \" + result + \"\\t 版本号实际值为：\" + atomicStampedReference.getStamp()); System.out.println(\"当前值为：\" + atomicStampedReference.getReference().toString()); }, \"t4\").start(); } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-20 23:20:15 "},"view/juc/collection.html":{"url":"view/juc/collection.html","title":"集合类","keywords":"","body":"集合类 ArrayList是线程不安全，举例说明 public class ContainerNotSafeDemo { public static void main(String[] args) { List list = Collections.synchronizedList(new ArrayList<>()); for(int i = 1; i { list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); }, String.valueOf(i)).start(); } /** * 1、故障现象 * java.util.ConcurrentModificationException * * * 2、导致原因 * add方法，没有加锁。不保证原子性 * * * 3、解决方案 * 3.1 new Vector<>() * 3.2 Collections.synchronizedList(new ArrayList<>()); * 3.3 new CopyOnWriteArrayList<>(); * * * 4、优化建议（同样的错误不犯第2次） * * */ } } CopyOnWriteArrayList 写时复制 添加数据时，并不直接待当前容器Object[] array中添加。而是将当前容器复制一份，得到一个新的容器newElements，大小加1。写完成后，再将原容器的引用指向新的容器。 好处：可以并发的读，不需要加锁，因为当前容器不会添加任何元素。体现读写分离思想，读和写不同的容器。 public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } } HashSet线程不安全，错误原因与ArrayList一样 底层是 CopyOnWriteArrayList public class CopyOnWriteArraySet extends AbstractSet implements java.io.Serializable { private static final long serialVersionUID = 5457747651344034263L; private final CopyOnWriteArrayList al; /** * Creates an empty set. */ public CopyOnWriteArraySet() { al = new CopyOnWriteArrayList(); } 1.1 Collections.synchronizedSet(new HashSet()); 1.2 new CopyOnWriteArraySet<>(); HashSet底层原理 HashSet底层是 HashMap public class HashSet extends AbstractSet implements Set, Cloneable, java.io.Serializable { static final long serialVersionUID = -5024744406713321676L; private transient HashMap map; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); /** * Constructs a new, empty set; the backing HashMap instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() { map = new HashMap<>(); } HashSet底层是HashMap，为啥 add前者一个参数，后者需要传2个参数 // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public boolean add(E e) { return map.put(e, PRESENT)==null; } public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } HashMap线程不安全，原因与上相同 1.1 new ConcurrentHashMap<>(); 1.2 Collections.synchronizedMap(new HashMap<>()); Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-24 23:06:07 "},"view/juc/heap_stack.html":{"url":"view/juc/heap_stack.html","title":"堆栈","keywords":"","body":"堆栈 变量传值 public class TestTransferValue { public void changeValue1(int age) { age = 30; } public void changeValue2(Person person) { person.setPersonName(\"xxx\"); } public void changeValue3(String str) { str = \"xxx\"; } public static void main(String[] args) { TestTransferValue test = new TestTransferValue(); int age = 20; test.changeValue1(age); System.out.println(\"age---\" +age); --- age---20 Person person = new Person(\"abc\"); test.changeValue2(person); System.out.println(\"personName---\" + person.getPersonName()); personName---xxx String str = \"abc\"; test.changeValue3(str); System.out.println(\"string---\" + str); string---abc } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-22 22:53:07 "},"view/lock/":{"url":"view/lock/","title":"锁","keywords":"","body":"锁 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-22 22:58:16 "},"view/lock/fair.html":{"url":"view/lock/fair.html","title":"公平锁","keywords":"","body":"公平锁与非公平锁 定义 public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 公平锁 指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到 非公平锁 指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程以先申请的线程优先获取锁。在高并发情况下，有可能会造成优先级反转或饥饿现象 区别 公平锁 按照申请锁的顺序来获取锁。FIFO等待队列 非公平锁 先直接尝试占有锁，如果失败，就再采用类似公平锁那种方式 非公平锁的优点在于吞吐量比公平锁大。 对于synchronized而言，也是一种非公平锁。 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-22 23:19:26 "},"view/lock/reentrantLock.html":{"url":"view/lock/reentrantLock.html","title":"可重入锁","keywords":"","body":"可重入锁（又名递归锁） 定义 指同一线程外层函数获取锁之后，内层递归函数仍然能获取该锁的代码即：线程可以进入任何一个它已经拥有的锁所同步着的代码块。 public sync void method01() { method02(); } public sync void method02() { } ReentrantLock/Synchronized就是一个典型的可重入锁 可重入锁最大的作用是避免死锁。 class Phone implements Runnable { public synchronized void sendSMS() { System.out.println(Thread.currentThread().getName() + \"\\t invoke sendSMS()\"); sendEmail(); } public synchronized void sendEmail() { System.out.println(Thread.currentThread().getName() + \"\\t invoke sendEmail()\"); } Lock lock = new ReentrantLock(); @Override public void run() { get(); } public void get() { lock.lock(); lock.lock(); try { System.out.println(Thread.currentThread().getName() + \"\\t invoke get()\"); set(); } finally { lock.unlock(); } } public void set() { lock.lock(); try { System.out.println(Thread.currentThread().getName() + \"\\t invoke set()\"); } finally { lock.unlock(); lock.unlock(); } } } public class ReentrantDemo { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -> { phone.sendSMS(); }, \"t1\").start(); new Thread(() -> { phone.sendSMS(); }, \"t2\").start(); Thread t3 = new Thread(phone, \"t3\"); Thread t4 = new Thread(phone, \"t4\"); t3.start(); t4.start(); } } 其中：lock可以加多次，只要保证 lock与unlock的次数一致，都是可以正常运行。另外：如果不一致，会导致程序一直执行，无输出结果。 下面这种也是可以正常执行。 public void get() { lock.lock(); try { System.out.println(Thread.currentThread().getName() + \"\\t invoke get()\"); set(); } finally { lock.unlock(); } } public synchronized void set() { try { System.out.println(Thread.currentThread().getName() + \"\\t invoke set()\"); } finally { } } synchronized和lock有什么区别？用新的lock有什么好处？举例说说 原始构成 synchronized是关键字属于JVM层面。 monitorenter(底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象只有在同步块或方法中才能调wait/nofity等方法) monitorexit 通过javap -c分析，有一次enter，2次exit。代表 正常退出，异常退出。保证不会死锁。 lock是具体类(java.util.concurrent.locks.Lock)是api层面的锁 使用方法 synchronzied不需要用户去手动释放锁，代码执行完系统让线程自动释放锁 reentrantLock需要用户去手动释放锁，若没有主动释放锁，则有可能出现死锁。需要lock和unlock方法配合try/finally语句块来完成。 等待是否可中断 synchronzied不可中断，除非抛出异常或者正常运行完成 reentrantLock可中断，1、设置超时方法 tryLock 2、lockInterruptibly放代码块中，调用interrupt方法可中断 加锁是否公平 synchronized非公平锁 reentrantLock默认非公平锁。构造方法传参，true为公平锁，flase非公平锁 锁绑定多个条件Condition synchronized没有 reentrantLock用来实现分组响醒需要唤醒的线程们，可以精确响醒，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。 /** * 3个线程 * * A打印5次，B打印10次，C打印15次。 * 总共打印10轮 */ import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * 多线程编程，步骤： * 1、创建资源类 * 2、判断、干活、通知 */ class ShareResource { private int number = 1; //A:1, B:2, C:3 Lock lock = new ReentrantLock(); private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); public void print(int flag) { lock.lock(); try { if (flag == 1) { while (number != 1) { c1.await(); } } if (flag == 2) { while (number != 2) { c2.await(); } } if (flag == 3) { while (number != 3) { c3.await(); } } for (int i = 1; i { shareResource.print(1); }, \"A\").start(); new Thread(() -> { shareResource.print(2); }, \"B\").start(); new Thread(() -> { shareResource.print(3); }, \"C\").start(); } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-25 22:06:33 "},"view/lock/spinlock.html":{"url":"view/lock/spinlock.html","title":"自旋锁","keywords":"","body":"自旋锁 定义 尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。 实现 可参考 CAS public class SpinLockDemo { AtomicReference atomicReference = new AtomicReference<>(); public void myLock() { Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + \"\\t come in\"); while (!atomicReference.compareAndSet(null, thread)) { } } public void myUnlock() { Thread thread = Thread.currentThread(); atomicReference.compareAndSet(thread, null); System.out.println(Thread.currentThread().getName() + \"\\t invoked myUnlock\"); } public static void main(String[] args) { SpinLockDemo spinLockDemo = new SpinLockDemo(); new Thread(() -> { spinLockDemo.myLock(); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } spinLockDemo.myUnlock(); }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -> { spinLockDemo.myLock(); spinLockDemo.myUnlock(); }, \"t2\").start(); } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-23 00:15:59 "},"view/lock/readwritelock.html":{"url":"view/lock/readwritelock.html","title":"读写锁","keywords":"","body":"读写锁 读写锁 读-读可共存 读-写不可共存 写-写不可共存 ReentrantReadWriteLock class MyCache { private volatile Map map = new HashMap<>(); private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(); public void put(String key, Object value) { rwLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + \"\\t 正在写入：\" + key); try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } map.put(key, value); System.out.println(Thread.currentThread().getName() + \"\\t 写入完成\"); } catch (Exception e) { e.printStackTrace(); } finally { rwLock.writeLock().unlock(); } } public void get(String key) { rwLock.readLock().lock(); try { System.out.println(Thread.currentThread().getName() + \"\\t 正在读取\"); Object result = map.get(key); System.out.println(Thread.currentThread().getName() + \"\\t 读取完成：\" + result); } catch (Exception e) { e.printStackTrace(); } finally { rwLock.readLock().unlock(); } } } public class ReadWriteLock { public static void main(String[] args) { MyCache myCache = new MyCache(); for(int i = 1; i { myCache.put(v_count+\"\", v_count+\"\"); }, String.valueOf(i)).start(); } for(int i = 1; i { myCache.get(v_count+\"\"); }, String.valueOf(i)).start(); } } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-23 22:36:43 "},"view/lock/countdownlatch.html":{"url":"view/lock/countdownlatch.html","title":"倒计时器","keywords":"","body":"倒计时器 CountDownLatch用给定的计数初始化。 await方法阻塞，直到由于countDown()方法的调用而导致当前计数达到零。 CountDownLatch 在java.util.concurrent.CountDownLatch中定义 public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i { System.out.println(Thread.currentThread().getName() + \"\\t 离开教室\"); countDownLatch.countDown(); }, String.valueOf(i)).start(); } System.out.println(\"当前还剩人数：\" + countDownLatch.getCount()); countDownLatch.await(); System.out.println(Thread.currentThread().getName() + \"\\t 班长离开教室\"); } } 枚举 public enum CountryEnum { ONE(1, \"齐\"), TWO(2, \"楚\"), THREE(3, \"韩\"), FOUR(4, \"魏\"), FIVE(5, \"赵\"), SIX(6, \"燕\"); private Integer retCode; private String retMessage; public Integer getRetCode() { return retCode; } public String getRetMessage() { return retMessage; } CountryEnum(Integer retCode, String retMessage) { this.retCode = retCode; this.retMessage = retMessage; } public static String forEach_CountryEnum(int index) { CountryEnum[] values = CountryEnum.values(); for (CountryEnum element : values) { if (index == element.getRetCode()) { return element.getRetMessage(); } } return null; } } public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i { System.out.println(Thread.currentThread().getName() + \"\\t 国，被灭\"); countDownLatch.countDown(); }, CountryEnum.forEach_CountryEnum(i)).start(); } System.out.println(\"当前还剩人数：\" + countDownLatch.getCount()); countDownLatch.await(); System.out.println(Thread.currentThread().getName() + \"\\t 秦帝国，一统华夏\"); } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-23 23:21:12 "},"view/lock/cyclicbarrier.html":{"url":"view/lock/cyclicbarrier.html","title":"可重用屏障/栅栏","keywords":"","body":"可重用屏障/栅栏 CyclicBarrier支持一个可选的Runnable命令，每个屏障点运行一次，在派对中的最后一个线程到达之后，但在任何线程释放之前。 在任何一方继续进行之前，此屏障操作对更新共享状态很有用。 CyclicBarrier public class CyclicBarrierDemo { public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> { System.out.println(\"召唤神龙\"); }); for(int i = 1; i { System.out.println(Thread.currentThread().getName() + \"\\t 找到第 \" + v_count + \" 颗龙珠\"); try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }, String.valueOf(i)).start(); } } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-23 23:21:31 "},"view/lock/semaphore.html":{"url":"view/lock/semaphore.html","title":"信号量","keywords":"","body":"信号量 用于多个共享资源的互斥使用 用于并发线程数的控制 Semaphore public class SemaphoreDemo { public static void main(String[] args) { Semaphore semaphore = new Semaphore(3); for(int i = 1; i { try { semaphore.acquire(); System.out.println(Thread.currentThread().getName() + \"\\t 抢到车位\"); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"\\t 停车3秒后离开车位\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }, String.valueOf(i)).start(); } } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-23 23:33:55 "},"view/lock/block_queue.html":{"url":"view/lock/block_queue.html","title":"阻塞队列","keywords":"","body":"阻塞队列 定义 当阻塞队列是空时，从队列中获取元素的操作会被阻塞 当阻塞队列是满时，往队列中添加元素的操作会被阻塞 为什么用？有什么好处？ 多线程环境下，所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被响醒 为什么需要BlockingQueue 好处是我们不需要关心什么时候需要阻塞线程，什么时候需要响醒线程，因为这一切BlockingQueue都给你一手包办了。 在concurrent包发布之前，在多线程环境下，我们每个程序员都必须去自已控制这些细节。尤其要兼顾效率和线程安全，带来了不小的复杂度。 异常组 public static void main(String[] args) { //List list = new ArrayList<>(); 1、//由数组结构组成的有界阻塞队列 BlockingQueue blockingQueue = new ArrayBlockingQueue<>(3); System.out.println(blockingQueue.add(\"a\")); System.out.println(blockingQueue.add(\"b\")); 2、//由链表结构组成的有界（但大小默认Integer.MAX_VALUE）阻塞队列 BlockingQueue blockingQueue = new LinkedBlockingQueue<>(3); 3、//不存储元素的阻栋队列，也即单个元素消费后，才生产下个元素 BlockingQueue blockingQueue = new SynchronousQueue<>(); add (插入) blockingQueue.add(\"a\") // IllegalStateException: Queue full remove (移除) blockingQueue.remove() //the head of this queue.if null, then NoSuchElementException element (检查) blockingQueue.element() //the head of this queue.if null, then NoSuchElementException 特殊值 offer （插入） 成功true,失败false poll (移除) 成功返回队列头部信息，失败则返回null peek (检查) the head of this queue, or {@code null} if this queue is empty 阻塞 put(e) （插入） 当阻塞列表满时，生产者线程继志往队列中put元素，队列会一直阻塞线程直到put数据or响应中断退出 take() (移除) 当阻栋列表空时，消费者线程试图从队列中take元素，队列会一直阻塞消费者线程直到队列可用 超时 offer(e, time, out) （插入） time时间到后，插入成功返回true,失败返回false。不阻塞 poll(time, unit) (移除) time时间到后，获取成功返回头元素，失败返回null public static void main(String[] args) throws InterruptedException { //List list = new ArrayList<>(); BlockingQueue blockingQueue = new SynchronousQueue<>(); new Thread(() -> { try { System.out.println(Thread.currentThread().getName() + \"\\t put 1\"); blockingQueue.put(\"1\"); System.out.println(Thread.currentThread().getName() + \"\\t put 2\"); blockingQueue.put(\"2\"); System.out.println(Thread.currentThread().getName() + \"\\t put 3\"); blockingQueue.put(\"3\"); } catch (InterruptedException e) { e.printStackTrace(); } }, \"AAA\").start(); new Thread(() -> { try { TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"\\t take \" + blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"\\t take \" + blockingQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"\\t take \" + blockingQueue.take()); } catch (InterruptedException e) { e.printStackTrace(); } }, \"BBB\").start(); } BlockingQueue核心 架构 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-25 00:00:42 "},"view/lock/producer_consumer.html":{"url":"view/lock/producer_consumer.html","title":"生产者+消费者","keywords":"","body":"生产者+消费者 生产者+消费者 volatile(可见性)/CAS/atomicInteger/BlockQueue/线程交互/原子引用 class Resource { private volatile boolean FLAG = true; //默认开启生产+消费 private AtomicInteger atomicInteger = new AtomicInteger(); BlockingQueue blockingQueue = null; public Resource(BlockingQueue blockingQueue) { //永远记住，传参 传接口 this.blockingQueue = blockingQueue; System.out.println(blockingQueue.getClass().getName()); } public void myProd() { String data = null; boolean retval; while (FLAG) { data = atomicInteger.incrementAndGet() + \"\"; try { retval = blockingQueue.offer(data, 2L, TimeUnit.SECONDS); if (retval) { System.out.println(Thread.currentThread().getName() + \"\\t 生产数据\" + data); } else { System.out.println(\"boss叫停，生产暂停\"); } } catch (InterruptedException e) { e.printStackTrace(); } try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } } public void myConsumer() { String data = null; while (FLAG) { try { data = blockingQueue.poll(2L, TimeUnit.SECONDS); if (data == null || \"\".equalsIgnoreCase(data)) { return; } System.out.println(Thread.currentThread().getName() + \"\\t 消费数据\" +data); } catch (InterruptedException e) { e.printStackTrace(); } } } public void myStop() { this.FLAG = false; } } /** * volatile/CAS/atomicInteger/BlockQueue/线程交互/原子引用 */ public class ProdConsumer_BlockQueueDemo { public static void main(String[] args) { Resource resource = new Resource(new ArrayBlockingQueue<>(10)); new Thread(() -> { resource.myProd(); }, \"A\").start(); new Thread(() -> { resource.myConsumer(); }, \"B\").start(); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } resource.myStop(); } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-25 23:25:00 "},"view/lock/dead_lock.html":{"url":"view/lock/dead_lock.html","title":"死锁","keywords":"","body":"死锁 指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去。如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低。 原因 系统资源不足 进程运行推进的顺序不对 资源分配不当 例子 //线程资源类 class ThreadLockDemo implements Runnable { private String lockA; private String lockB; public ThreadLockDemo(String lockA, String lockB) { this.lockA = lockA; this.lockB = lockB; } @Override public void run() { synchronized (lockA) { System.out.println(Thread.currentThread().getName() + \"\\t 持有\" + lockA + \" 尝试获取\" + lockB); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lockB) { System.out.println(Thread.currentThread().getName() + \"\\t 持有\" + lockB + \" 尝试获取\" + lockA); } } } } /** * 死锁例子 */ public class DeadLockDemo { public static void main(String[] args) { String lockA = \"lockA\"; String lockB = \"lockB\"; new Thread(new ThreadLockDemo(lockA, lockB), \"AAA\").start(); new Thread(new ThreadLockDemo(lockB, lockA), \"BBB\").start(); } } 分析是否为死锁 idea中Terminal输入jps -l查看当前运行进程 jps 类似于linux下的 ps -ef | grep xxx，它是windows下的，只是用于查看java的。 F:\\2019H2\\java_code>jps -l 12368 org.jetbrains.idea.maven.server.RemoteMavenServer 15744 sun.tools.jps.Jps 8368 9120 org.jetbrains.jps.cmdline.Launcher 6484 com.zhou.java.lock.DeadLockDemo 10924 org.jetbrains.jps.cmdline.Launcher 查看6484进程的执行情况，使用jstack 6484 Java stack information for the threads listed above: =================================================== \"BBB\": at com.zhou.java.lock.ThreadLockDemo.run(DeadLockDemo.java:27) - waiting to lock (a java.lang.String) - locked (a java.lang.String) at java.lang.Thread.run(Thread.java:748) \"AAA\": at com.zhou.java.lock.ThreadLockDemo.run(DeadLockDemo.java:27) - waiting to lock (a java.lang.String) - locked (a java.lang.String) at java.lang.Thread.run(Thread.java:748) Found 1 deadlock. Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-13 22:13:30 "},"view/thread_poll/":{"url":"view/thread_poll/","title":"线程池","keywords":"","body":"线程池 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-25 22:41:37 "},"view/thread_poll/callable.html":{"url":"view/thread_poll/callable.html","title":"Callable接口","keywords":"","body":"Callable接口 Runnable Thread Callable 与 Runnable区别？ Runnable没有返回值，Callable有返回值 Runnable不报异常，Callable抛出异常 Runnable执行run,Callable执行call 实现 //第1种 class MyThread implements Runnable { @Override public void run() { } } //第2种 class MyThread2 extends Thread { @Override public void run() { } } //第3种 class MyThread3 implements Callable { @Override public Integer call() throws Exception { System.out.println(Thread.currentThread().getName() + \"\\t come in\"); return 1024; } } public class CallableDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { //传统的java.lang.Thread的入参，只有Runnable。需要找一个继承Runnable、Callable的方法。 FutureTask futureTask = new FutureTask<>(new MyThread3()); //使用Thread执行 new Thread(futureTask, \"AA\").start(); //BB与AA执行同样的方法，不会去执行。come in打印只有一条。 new Thread(futureTask, \"BB\").start(); int result = 100; //get建议放在靠后的位置。当futureTask执行时间长时，会导致阻塞。 int result02 = futureTask.get(); System.out.println(\"返回结果：\" + (result + result02)); } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-25 23:23:29 "},"view/thread_poll/poll.html":{"url":"view/thread_poll/poll.html","title":"线程池","keywords":"","body":"线程池 后面带s的是辅助工具类。 // Array Arrays // Collection Collections // Executor Executors 架构 线程池的底层是 ThreadPoolExecutor public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); } 实现 public class ThreadPoolDemo { public static void main(String[] args) { //ExecutorService threadPool = Executors.newFixedThreadPool(5); //一池固定数据线程 //ExecutorService threadPool = Executors.newSingleThreadExecutor();//一池单个 ExecutorService threadPool = Executors.newCachedThreadPool();//缓存 try { for(int i = 1; i { //Runnable 函数式接口，可采用lamba表达式 System.out.println(Thread.currentThread().getName() + \"\\t 办理业务\"); }); //threadPool.submit(); } } catch (Exception e) { e.printStackTrace(); } finally { threadPool.shutdown(); } } } newFixedThreadPool public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } newSingleThreadExecutor public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())); } newCachedThreadPool public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); } newScheduledThreadPool newWorkStealingPool 七大参数意义 corePoolSize: 核心线程数 maximumPoolSize：最大线程数 keepAliveTime： TimeUnit： BlockingQueue： threadFactory： RejectedExecutionHandler：拒绝策略 线程池拒绝策略 等待队列已经排满了，再也塞不下新任务。同时，线程池中的max线程也达到了，无法继续为新任务服务。这个时候需要拒绝策略机制，来合理处理这个问题。 AbortPolicy（默认）：直接抛出RejectedExecutionException异常阻止系统正常运行； DiscardPolicy：直接丢弃任务，不予处理也不抛出异常。如果允许任务丢失，这是最好的一种方案； CallerRunsPolicy：\"调用者运行\"一种调节机制，不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者； DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务 工作中单一的/固定的/可变的三种创建线程池的方法，你用哪个多？超线大坑 一个都不用。原因：据阿里巴巴规约 并发编程下： 固定的/单一的线程，调用了LinkedBlockingQueue队列，支持MAX_VALUE个数，容易造成OOM。 可变的，支持MAX_VALUE个数，容易造成OOM 自定义线程池 public class ThreadPoolDemo { public static void main(String[] args) { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 5, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue<>(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy() ); try { for(int i = 1; i { System.out.println(Thread.currentThread().getName() + \"\\t 办理业务\"); }); } } finally { threadPoolExecutor.shutdown(); } } } AbortPolicy策略（抛出异常） pool-1-thread-1 办理业务 Exception in thread \"main\" java.util.concurrent.RejectedExecutionException: Task pool-1-thread-1 办理业务 CallerRunsPolicy策略（任务回退给调用者） pool-1-thread-1 办理业务 main 办理业务 main 办理业务 pool-1-thread-1 办理业务 DiscardPolicy、DiscardOldestPolicy策略 （数量变少，任务被丢弃） pool-1-thread-1 办理业务 pool-1-thread-2 办理业务 pool-1-thread-2 办理业务 pool-1-thread-2 办理业务 pool-1-thread-2 办理业务 pool-1-thread-3 办理业务 pool-1-thread-4 办理业务 pool-1-thread-5 办理业务 如何合理配置线程池参数 CPU密集型： 配置尽可能少的线程数量（一般公式：CPU核数+1个线程的线程池） IO密集型： 1、由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数 * 2 2、即该任务需要大量的IO，即大量的阻塞。参考公式：CPU核数/(1-阻塞系数) 阻塞系统在0.8~0.9之间。比如8核CPU： 8/ (1-0.9) = 80个线程数 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-29 00:53:21 "},"view/reference/":{"url":"view/reference/","title":"引用","keywords":"","body":"引用 强引用 Reference 当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死都不收。是造成JAVA内存泄漏的主要原因之一。 软引用 SoftReference 当内存够用，不回收。内存不够用，回收。 弱引用 WeakReference 不管内存够不够用,只要有GC，都回收 weakHashMap private static void myWeakHashMap() { WeakHashMap hashMap = new WeakHashMap<>(); Integer key = new Integer(1); String value = \"WeakHashMap\"; hashMap.put(key, value); System.out.println(hashMap); key = null; System.out.println(hashMap); System.gc(); System.out.println(hashMap); } {1=WeakHashMap} {1=WeakHashMap} {} 虚引用 PhantomReference 必须和引用队列一起使用。ReferenceQueue。 引用被回收前，需要放在 引用队列中保存下。完成回收前的动作。 应用场景 有一个应用需要读取大量的本地图片： 如果每次读取图片都从硬盘读取则会严重影响性能 如果一次性全部加载到内存中又可以造成内存溢出 可以使用软引用解决这个问题。 用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系。 Map> imageCache = new HashMap<>(); GC Roots与引用的关系图 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-08 22:41:42 "},"view/oom/":{"url":"view/oom/","title":"OOM","keywords":"","body":"OOM StackOverflowError （错误） 栈空间，默认大小为512K~1024K左右。循环方法调用，会导致栈空间溢出。 public class StackOverFlowErrorDemo { public static void main(String[] args) { myshow(); } private static void myshow() { myshow(); } } Exception in thread \"main\" java.lang.StackOverflowError at com.zhou.java.oom.StackOverFlowErrorDemo.myshow(StackOverFlowErrorDemo.java:10) at com.zhou.java.oom.StackOverFlowErrorDemo.myshow(StackOverFlowErrorDemo.java:10) OutOfMemoryError (错误) 大量对象调用，堆溢出 public static void main(String[] args) { String str = \"test\"; while (true) { str += str + new Random().nextInt(1111111) + new Random().nextInt(222222222); str.intern(); } } Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at com.zhou.java.oom.OutOfMemoryErrorDemo.main(OutOfMemoryErrorDemo.java:11) GC overhead limit exceeded -Xms10m -Xmx10m -XX:MaxDirectMemorySize=5m GC回收时间过长时会抛出OutOfMemoryError。超过98%的时间用来做GC 并且回收了不到2%的堆内存。连续多次GC都只回收了不到2%的极端情况下才会抛出。 public static void main(String[] args) { int i = 0; List list = new ArrayList<>(); try { while (true) { list.add(String.valueOf(++i).intern()); } } catch (Throwable e) { System.out.println(\"===============\" + i); e.printStackTrace(); throw e; } } ===============145445 java.lang.OutOfMemoryError: GC overhead limit exceeded at java.lang.Integer.toString(Integer.java:403) at java.lang.String.valueOf(String.java:3099) at com.zhou.java.oom.GCOverheadDemo.main(GCOverheadDemo.java:13) Exception in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded at java.lang.Integer.toString(Integer.java:403) at java.lang.String.valueOf(String.java:3099) at com.zhou.java.oom.GCOverheadDemo.main(GCOverheadDemo.java:13) Direct buffer memory (NIO中遇到的多) -Xms10m -Xmx10m -XX:MaxDirectMemorySize=5m public static void main(String[] args) { System.out.println(VM.maxDirectMemory() / (1024.0 * 1024)); ByteBuffer byteBuffer = ByteBuffer.allocateDirect(6 * 1024 * 1024); } Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:693) at java.nio.DirectByteBuffer.(DirectByteBuffer.java:123) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311) at com.zhou.java.oom.DirectBufferMemoryDemo.main(DirectBufferMemoryDemo.java:11) unable to create new native thread （高并发） 同一个Thread如果多次start，会报 IllegalThreadStateException vim /etc/security/limits.d/90-nproc.conf root用户，不限制个数 非root用户，默认1024。正常创建线程900多左右，就会出现上面的错误。 metaspace (元空间) -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m public class MetaSpaceDemo { static class OOMTest {} public static void main(String[] args) { int i = 0; try { while (true) { Enhancer enhancer = new Enhancer(); // cglib 动态代理 enhancer.setSuperclass(OOMTest.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { return methodProxy.invokeSuper(o, args); } }); enhancer.create(); } } catch (Exception e) { System.out.println(\"============: \" + i); e.printStackTrace(); } } } Exception in thread \"main\" java.lang.OutOfMemoryError: Metaspace at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:348) at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:467) at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:339) at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492) at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:117) at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294) at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480) at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305) at com.zhou.java.oom.MetaSpaceDemo.main(MetaSpaceDemo.java:27) Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-09 00:10:42 "},"view/jvm_gc/":{"url":"view/jvm_gc/","title":"JVM+GC","keywords":"","body":"JVM+GC Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-02 09:07:29 "},"view/jvm_gc/gc.html":{"url":"view/jvm_gc/gc.html","title":"GC","keywords":"","body":"GC GC的作用域 方法区和堆，参见 JVM体系结构概览。 常见的垃圾回收算法 GC四大算法： 引用计数：很久之前用的，缺点明显 新生代采用复制算法，不会产生内存碎片，但是浪费内存 老年代采用标记清除，会产生内存碎片 标记压缩，在标记清除的基础上，移动对象，规避内存碎片，但是移动对象会有损耗； 引用计数法 （JVM的实现一般不采用这种方式） 对象调用+1，释放-1. 缺点： 每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗； 较难处理 循环引用 复制 标记清除 算法分成标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象。 优点：不需要大面积复制对象，缺点：会产生内存碎片 标记压缩 GC Roots 字符串结束符'\\0' 垃圾 内存中已经不再被使用到的空间就是垃圾 如何判断一个对象是否可以被回收 引用计数法 （不使用） 枚举根节点做可达性分析(根搜索路径) 哪些对象可以用为 GC Roots的对象 虚拟机栈（栈帧中的局部变量，也叫做局部变量表）中引用的对象 方法区中的类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(Native方法)引用的对象 GC详细日志查看 -XX:PrintGCDetails: 查看GC收集的详细日志 GC在新生代区，Full GC在老年代区 GC Hello [GC (Allocation Failure) [PSYoungGen: 2041K->488K(2560K)] 2041K->712K(9728K), 0.0039801 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 488K->504K(2560K)] 712K->728K(9728K), 0.0007173 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 504K->0K(2560K)] [ParOldGen: 224K->674K(7168K)] 728K->674K(9728K), [Metaspace: 3492K->3492K(1056768K)], 0.0043729 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] 674K->674K(9728K), 0.0004317 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K->0K(2560K)] [ParOldGen: 674K->656K(7168K)] 674K->656K(9728K), [Metaspace: 3492K->3492K(1056768K)], 0.0072861 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap PSYoungGen total 2560K, used 57K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000) eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0e7a0,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 7168K, used 656K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000) object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a4030,0x00000000ffd00000) Metaspace used 3524K, capacity 4502K, committed 4864K, reserved 1056768K class space used 391K, capacity 394K, committed 512K, reserved 1048576K Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space at com.zhou.java.test.Test.main(Test.java:18) GC Full GC 垃圾收集器 GC算法是内存回收的方法论，垃圾收集器就是算法落地实现。 Serial 串行垃圾回收器 它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境。 Parallel 并行垃圾回收器 多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理首台处理等弱交互场景。 CMS 并发垃圾回收器 用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程。互联网公司多用它，适用对响应时间有要求的场景。 G1 (java9默认，10年时间验证) ZGC （java11以上） 垃圾收集器 怎么查看服务器默认的垃圾收集器java -XX:+PrintCommandLineFlags -version 垃圾收集器种类UseSerialGC --- Serial CopyingUseConcMarkSweepGC --- CMSUseParNewGC --- ParNewUserParallelGC --- Parallel ScavengeUseParallelOldGC --- Paralll CompactingUseG1GC 其中，Serial MSC (Serial Old),java8中已经废弃。 如何选择垃圾收集器 谈谈你对垃圾收集器的理解 GC约定参数说明 DefNew: Default New Generation Tenured: Old ParNew: Parallel New Generation PSYoungGen: Parallel Scavenge ParOldGen: Parallel Old Generation Serial收集器 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialGC (DefNew+Tenured)JVM参数：-XX:UseSerialGC开启后：Serial(Young区用) + Serial Old(Old区用)的收集器组合表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法。 ParNew收集器 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParNewGC (ParNew+Tenured)是Serial收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的CMS GS工作，其余行为和Serial收集器完全一样。它是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。JVM参数：-XX:UseParNewGC开启后：只影响新生代的收集，不影响老年代。ParNew(Young区用) + Serial Old(Old区用)的收集器组合 表示：新生代使用复制算法，老年代使用标记-整理算法。 **但是，ParNew+Tenured这样的搭配，java8已经不再被推荐。** Parallel收集器 （默认） -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelGC (PSYoungGen+ParOldGen) 吞吐量优先收集器。关注的重点如下： 可控制的吞吐量（=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）。高吞吐量意味着高效利用CPU时间，它多用于后台运算而不需要太多交互的任务。 自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大的吞吐量。JVM参数：-XX:UseParallelGC或-XX:UseParallelOldGC(可互相激活)使用Parallel Scavenge收集器。 Parallel Old收集器 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC (PSYoungGen+ParOldGen) 为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以配置。在jdk1.6之前(Parallel Scavenge + Serial Old)。在jdk1.8之后(Parallel Scavenge + Parallel Old)-XX:UseParallelOldGC CMS收集器 -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseConcMarkSweepGC (par new generation + concurrent mark-sweep)并发标记清除收集器。是一种以获取最短回收停顿时间为目标的收集器。适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。-XX:+UseConcMarkSweepGC，开启后会自动将-XX:UseParNewGC打开。使用ParNew(Young区用)+CMS(Old区用)+Serial Old的收集器组合，Serial Old将作为CMS出错的后备收集器。 有4步过程，如下： 初始标记(CMS initial mark)：只中标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 并发标记(CMS concurrent mark)：进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象。 重新标记(CMS remark)：修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正。 并发清除(CMS concurrent sweep)：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户一起并发工作。所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。 **优缺点**： 优点：并发收集停顿低 缺点：并发执行，对CPU资源压力大；采用的标记清除算法会导致大量碎片。-XX:CMSFullGCsBeForeCompaction来指定多少次CMS收集之后，进行一次压缩的Full GC。 SerialOld收集器 理论知道即可，实际中java8已经被优化掉了，没有了。-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -XX:+UseSerialOldGC是Serial垃圾收集器的老年代版本，同样是单线程的收集器，使用标记整理算法，主要是运行在Client默认的java虚拟机默认的老年代垃圾收集器。主要两个用途：1、jdk1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。2、作为老年代版中使用CMS收集器的后备垃圾收集方案。 G1垃圾收集器 以前收集器特点 年轻代和老年代是各自独立且连续的内存块 年轻代收集使用单eden+SO+S进行复制算法 老年代收集必须扫描整个老年代区域 都是以尽可能少而快速地执行GC为设计原则 G1是什么 是一款面向服务端应用的收集器，应用在多处理器和大容量内存环境中。有以下特性： 像CMS一样，与应用程序线程并发执行 整理空闲空间更快 需要更多的时间预测GC停顿时间 不希望牺牲大量的吞吐性能 不需要更大的Java Heap 设计目标是取代CMS收集器，与CMS相比，以下2点更出色： 是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片 Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。 主要改变是： Eden、Survivor、Tenured等内存区域不再连续，而是变成一个个大小一样的region 每个region从1M到32M不等，一个region有可能属于Eden、Survivor或者Tenured内存区域。 特点： G1充分利用多CPU、多核环境，尽量缩短STW G1整体采用标记-整理算法，局部通过复制算法，不会产生内存碎片 宏观上G1不区分年轻代和老年代，把内存划分成多个独立的子区域 其本身依然在小范围内要进行年轻代和老年代的区分，不再物理隔离，依然会采用不同的GC方式来处理不同的region G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换 底层原理 区域化内存划分region，整体编为了一些不连续的内存区域，避免了全内存区的GC操作。 H默认在老年区，用于放置大对象。 回收原理，针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片： Eden区数据移动到Survivor区，假如Survivor区空间不够，Eden区数据会部分晋升到Old区 Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区 最后Eden区收拾干净了，GC结束，用户的应用程序继续执行 参数 -XX:+UseG1GC -XX:G1HeapRegionSize=n。值是2的幂，范围1-32MB，最大2048 -XX:MaxGCPauseMillis=n 最大GC停顿时间 -XX:InitiatingHeapOccupancyPercent=n 堆点用了多少的时候触发GC -XX:ConcGCThreads=n 并发GC使用的线程数 -XX:G1ReservePercent=n 设置作为空闲空间的预留内存百分比 小总结 JVM、GC结合Spring Boot微服务调参 java -server [JVM参数] -jar xxx.war jps -l jinfo -flags pid Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-10 14:58:01 "},"view/jvm_gc/jvm.html":{"url":"view/jvm_gc/jvm.html","title":"JVM","keywords":"","body":"JVM JVM内存结构 JVM体系结构概览 类加载器，分为4种。启动类（根）、扩展类、应用类、自定义类。 图中灰色的，线程私有，几乎不存在GC。 GC作用域：橙色部分。大概率存在GC。 Jdk8以后的JVM 移除了 Permanent Generatien for VM metadata添加了 Metaspace VM Metadata in native memory JVM调优及参数配置 JVM参数类型 标配参数 -version -help java -showversion X参数（了解） -Xint: 解释执行 -Xcomp: 第一次使用就编译成本地代码 -Xmixed: 混合模式 （java默认） XX参数 (重点) Boolean类型 公式：-XX:+或者-某个属性值 （+表示开启，-表示关闭） 是否打印GC收集细节jinfo -flag PrintGCDetails 13632 -XX:+PrintGCDetails-XX:-PrintGCDetails 是否使用串行垃圾回收器-XX:+UseSerialGC-XX:-UseSerialGC KV设值类型 公式：-XX:属性key=属性值value 配置元空间 jinfo -flag MetaspaceSize 4300 -XX:MetaspaceSize=128m 新生代老年代交换次数，默认15次 -XX:MaxTenuringThreshold=15 jinfo举例 如何查看当前运行程序的配置jinfo -flag 配置项 进程编号 jps -l jinfo -flag InitialHeapSize pid jinfo -flags pid 题外话（坑题） 栈管运行，堆管存储 -Xms: 等价于 -XX:initialHeapSize 初始大小内存 默认为物理内存的1/64 -Xmx: 等价于 -XX:MaxHeapSize 最大分配内存 默认为物理内存的1/4 -Xss: 等价于 -XX:ThreadStackSize 设置单个线程栈的大小，一般默认为512K~1024K (=0，代表默认值，依赖于平台，参见官网) -Xmn: 等价于 设置年轻代大小 -XX:MetaspaceSize: 元空间（不在虚拟机中，而是使用本地内存） -XX:PrintGCDetails: 输出详细GC收集日志信息 -XX:SurvivorRatio: 设置新生代中eden和S0/S1空间的比例。默认-XX:SurvivorRatio=8，Eden:S0:S1=8:1:1。设置eden的比例多少，S0、S1比例相同。 -XX:NewRatio： 设置老年代的占经，剩下的1给新生代。如NewRatio=2，则新生代占1，老年代占2。 -XX:MaxTenuringThreshold：默认值15，设置新生代转为老年代的阀值。 　查看JVM家底参数（重要） java -XX:+PrintFlagsInitial -version （查看默认值） java -XX:+PrintFlagsFinal -version （查看修改更新） 其中：=、:=（代表改动过） -XX:+PrintCommandLineFlags Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-05 00:26:24 "},"view/linux/":{"url":"view/linux/","title":"Linux常用命令","keywords":"","body":"Linux常用命令 top整机 %CPU %MEM load average: A B C。其中，ABC分别代表：1分钟、5分钟、15分钟的平均负载。如果(A+B+C)/3 > 60%，代表系统负载压力大 uptime 精简版top vmstat (cpu) vmstat -n 2 3 。每2秒采样，采样3次 pidstat (cpu) mpstat -p ALL 2 pidstat -u 1 -p pid free free [-g] [-m] 磁盘IO iostat -xdk 2 3 %util接近100%，表示磁盘带宽饱和 pidstat -d 2 -p pid 网络IO ifstat 1 如果CPU占用过高，具体定位分析 结合linux和jdk命令一起分析 先用top命令找出CPU占比最高的 ps -ef | jps -l，得知具体程序 （ps -ef | grep java | grep -v grep） 定位具体线程或代码 ps -mp 进程 -o THREAD,tid,time 将线程ID转为16进制小写 jstack 进程ID | grep tid -A60 Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-13 22:12:14 "},"view/github/":{"url":"view/github/","title":"GitHub","keywords":"","body":"GitHub 常用项 watch fork star clone follow in操作 in:name in:description in:readme 如：seckill in:name 或 seckill in:name,readme stars、forks springboot stars: >= 5000 springboot forks: > 5000 springboot forks:100..200 stars:80..100 awesome加强搜索 (重要) awesome redis 高亮显示 地址 #L 行号 地址 #L 行号 - L 行号 项目内搜索 英文t，展开式查看代码 搜索某个地区的大佬 location:地区 language:语言 **更多可查看github官网** Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-13 22:04:39 "},"jvm/":{"url":"jvm/","title":"深入理解JVM","keywords":"","body":"深入理解JVM Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-27 16:36:22 "},"jvm/mnemonics.html":{"url":"jvm/mnemonics.html","title":"助记符","keywords":"","body":"助记符 javap -c xxx.class 查看 ldc: 表示将int、float或者String类型的常量值从常量池中推送至栈顶 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String hello world 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return bipush：表示将单字节(-128~127)的常量值推送至栈顶 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: bipush 7 5: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 8: return sipush：表示将一个短整型常量值(-32768~32767)推送至栈顶 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: sipush 128 6: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 9: return iconst_1：表示将int类型1推送至栈顶 (iconst_m1 - iconst_5) 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: iconst_1 4: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 7: return anewarray: 表示创建一个引用类型的（如类、接口、数组）数组，并将其引用值压入栈顶 0: iconst_1 1: anewarray #2 // class com/zhou/java/jvm/MyParent4 4: astore_1 newarray: 表示创建一个指定的原始类型（如int、float、char等）的数组，并将其引用值压入栈顶 58: iconst_1 59: newarray int Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-28 23:09:00 "},"jvm/lesson_1.html":{"url":"jvm/lesson_1.html","title":"学习1","keywords":"","body":"学习1 类加载器 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构。 在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的。 加载：查找并加载类的二进制数据 连接： 验证： 确保被加载的类的正确性 准备： 为类的静态变量分配内存，并将其初始化为默认值(如 static int a = 1，那默认值为0) 解析： 把类中的符号引用转换为直接引用（符号引用：一个类中方法引用了另外的一个类；直接引用：直接通过指针的方法指向目标对象的内存位置）初始化：为类的静态变量赋予正确的初始值 .class加载方式 从本地系统中直接加载 通用网络下载.class文件 从zip、jar等归档文件中加载.class文件 从专用数据库中提取.class文件 将Java源文件动态编译为.class文件（类似动态代理） 类的使用方式 Java程序对类的使用方法可分为两种： 主动使用 被动使用 （不初始化） 所有的Java虚拟机实现必须在每个类或接口被Java程序 首次主动使用 时才初始化化们。 主动使用（七种） 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 （助记符getstatic、putstatic） 调用类的静态方法（invokestatic） 反射（如Class.forName(\"com.test.Test\")） 初始化一个类的子类 （两个类：parent、child。child初始化是对parent的主动使用） Java虚拟机启动时被标明为启动类的类(Java Test、main) JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化。 示例1 class MyParent { public static String str = \"hello world\"; static { System.out.println(\"MyParent static block\"); } } class MyChild extends MyParent { public static String str2 = \"welcome\"; static { System.out.println(\"MyChild static block\"); } } public class ClassLoaderDemo { public static void main(String[] args) { System.out.println(MyChild.str); System.out.println(MyChild.str2); } } MyChild.str 返回如下 原因：对于静态字段来说，只有直接定义了该字段的类才会被初始化 MyParent static block hello world MyChild.str2 返回如下 原因：对应主动使用的第5条，当一个类在初始化时，要求其父类全部都已经初始化完毕了 MyParent static block MyChild static block welcome -XX:+TraceClassLoading，用于追踪类的加载信息并打印出来 -XX:+，表示开启option选项 -XX:-，表示关闭option选项 -XX:=，表示将option选项的值设置为value 示例2 //本质上，调用类并没有直接引用到定义常量的类，因此并不会触发 //定义常量的类的初始化 //注意：这里指的是将常量存放到了ClassLoaderDemo的常量池中，之后ClassLoaderDemo与MyParent2 //就没有任何关系了。甚至，我们可以将MyParent2的class文件删除。 class MyParent2 { public static final String str = \"hello world\"; static { System.out.println(\"MyParent2 static block\"); } } public class ClassLoaderDemo { public static void main(String[] args) { System.out.println(MyParent2.str); } } 输出结果： hello world 原因：加了final关键字。在编译阶段，这个常量就会被存入到调用这个常量的方法所在的类的常量池当中。 示例3 /* 当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中。 这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化。 */ public class MyTest3 { public static void main(String[] args) { System.out.println(MyParent3.str); } } //UUID在编译时，无法知道具体值。只能在运行时才会知道。 class MyParent3 { public static final String str = UUID.randomUUID().toString(); static { System.out.println(\"MyParent3 static code\"); } } 输出结果 (MyParent3类会初始化) MyParent3 static code 7bddd3a0-0cca-45e2-9dff-3ee6703aa64a 示例4 /** * 对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为[Lcom.zhou.java.jvm.MyParent4 * 这种形式。动态生成的类型，其父类型就是Object。 * * 对于数组来说，JavaDoc经常将构成数组的元素为Component，实际上就是将数组降低一个维度后的类型。 */ public class MyTest4 { public static void main(String[] args) { //MyParent4 myParent4 = new MyParent4(); MyParent4[] myParent4s = new MyParent4[1]; System.out.println(myParent4s.getClass()); MyParent4[][] myParent4s1 = new MyParent4[1][1]; System.out.println(myParent4s1.getClass()); System.out.println(myParent4s.getClass().getSuperclass()); System.out.println(myParent4s1.getClass().getSuperclass()); } } class MyParent4 { static { System.out.println(\"MyParent4 init\"); } } 示例5 /** * 当一个接口在初始化时，并不要求其父接口都完成了初始化 * 只有在真正使用到父接口的时候（如引用接口中所定义的常量时），才会初始化 */ public class MyTest5 { public static void main(String[] args) { System.out.println(MyChild5.b); } } interface MyParent5 { public static int a = 5; } interface MyChild5 extends MyParent5 { public static final int b = 6; //放置在常量池中，与MyChild5本身没有关系 public static final int c = new Random().nextInt(); //运行期生成 } 示例6 public class MyTest6 { public static void main(String[] args) { Singleton singleton = Singleton.getInstance(); System.out.println(\"counter1:\" + Singleton.counter1); System.out.println(\"counter2:\" + Singleton.counter2); } } /** * main中调用了类的静态方法，导致主动使用。会执行 准备、初始化的操作 * * 1、准备：给各变量赋默认值，如counter1为0，singleton为null，counter2为0 * 2、getInstance（）后，进行初始化操作，给counter1赋0，singleton调用构造方法，使得 * counter1、counter2都为1。接下来，counter2赋0。 * * 最终的结果为：counter1：1，counter2：0。 */ class Singleton { public static int counter1; //public static int counter2 = 0; private static Singleton singleton = new Singleton(); private Singleton() { counter1++; counter2++; //准备阶段的重要意义。counter2在后面初始化，在准备阶段赋值。程序不会报错，可正常执行。 System.out.println(\"temp : \" + counter2); } public static int counter2 = 0; //将counter2的定义，从上面移到了此处 public static Singleton getInstance() { return singleton; } } Copyright © zxw 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-28 23:52:55 "}}